#summary Using PyQt for User Interfaces in 3dsMax
#labels Python,3dsMax,Tutorial

== PyQt User Interfaces ==

So now that you're getting a handle on how to program 3dsMax in Python, how do you start building tools?

==== The Bad News ====

You can't create tools the Maxscript way.  Rollouts are not creatable on the fly, they are actually processed directly in C++ through a string parser, which means there is no way to create a rollout in Python.

==== The Good News ====

We really don't want to create Maxscript rollouts anyway.  The Qt C++/Python framework is a powerful, fast, and user friendly model.  For a lot of you Maxscript programmers, it will seem very complex at first (believe me, I've been there), but as you begin working with Qt, you will find it is insanely easy to develop tools (not just for 3dsMax either - you'll be able to write cross-platform applications in PyQt as well!).

== How does it work? ==

To really get started understanding Qt, you should read up about it on their [http://qt.nokia.com website].  Download the code, work through some PyQt examples.  But here is a crash course on using it:

*Maxscript*
{{{
rollout uiMainROLL "Rollout Item" (
   button uiTestBTN "Test"
)
createDialog uiMainROLL
}}}

Now, there are a bunch of ways to create Qt widgets and dialogs.  This would be the simplest:

*Python*
{{{
# Use the blur.wingui package vs. the default PyQt4 packages for windows and dialogs
# because these items contain 3dsMax specific code needed to run

from blur.wingui import Dialog
from PyQt4.QtGui import QPushButton

# Create the dialog
dialog = Dialog()
button = QPushButton( dialog )
button.setText( 'Test' )

# Launch the dialog
dialog.show()

}}}

So, this is a very simple example.  And while it may seem right now in this simple of an example that there is not much benefit from creating PyQt dialogs vs. Maxscript Rollouts - believe me, as you start designing more complex tools, it becomes invaluable.

=== Dialogs vs. Windows ===

Inside PyQt (and in our case, the blur.wingui module), you have access to Dialogs and Windows.  While they are very similar, there are some subtle differences.  These are the 2 main ones that I use to determine which to use.

*Menus*

If I need a menu in my tool, I'll use a window, as it natively has support for a menubar

{{{
from blur.wingui import Window
from PyQt4.QtGui import QMenu

# Create a window
window = Window()

# Create a menu
menu = QMenu( window )
menu.setTitle( '&File' )
menu.addAction( '&New File...' )
menu.addAction( '&Open File..' )
menu.addSeparator()
menu.addAction( '&Quit' )

# Add the menu to the menu bar
window.menuBar().addMenu( menu )
window.show()
}}}

*Modality*

Both dialogs and windows can be modal.  However, dialogs are designed for it, while windows require more from the scripter to do so.  To make a dialog modal, you simply replace the show() call with an exec_() call.

{{{
from blur.wingui import Dialog
dialog = Dialog()

# Notice how you block interaction with 3dsMax, and wait to continue to the next set of code
if ( dialog.exec_() ):  # Launch it modally
  print 'Accepted'
else:
  print 'Rejected'

# Notice how you can still interact with 3dsMax
dialog.show()           # Launch it modelessly
}}}

A window on the other hand does not have an exec_ function, and you as the scripter will need to determine if it is accepted or rejected.

{{{
# Launch the window
from blur.wingui  import Window
from PyQt4.QtCore import Qt

window = Window()
window.setWindowModality( Qt.ApplicationModal )   # Makes the window modal
window.show()  # Has no 'exec_' so does not return accepted/rejected
}}}

=== Sub-Classing ===

While the above example created a dialog and then added a button to it, that is not the generally preferred method to creating dialogs.  Normally, you will subclass a Dialog and create your own Dialog instance.

If you aren't up to speed on subclassing from the [Py3dsMaxTutClasses Structs & Classes] page, then you should get up to speed on how it works doing Python/PyQt docs and tutorials.

*Python*
{{{
from blur.wingui  import Dialog
from PyQt4.QtGui  import QPushButton

class MyDialog( Dialog ):
   def __init__( self ):
      Dialog.__init__( self )
      
      button = QPushButton( self )
      button.setText( 'Test' )

dialog = MyDialog()
dialog.show()
}}}

=== Layouts ===

Ok, so we have a dialog with a button...whoop-dee-do.  It still looks pretty bad, what can we do that is better than in Maxscript?

In 3dsMax, if you COULD resize a rolloutcontrol, you'd be responsible for all the resizing code for it - which often time was a large enough pain that no one did it.

Qt removes the need for that with these things called Layouts.  Lets build a more exciting dialog this time shall we?

*Python*
{{{
from blur.wingui  import Dialog

from PyQt4.QtGui  import QHBoxLayout      # Spread widgets horizontally
from PyQt4.QtGui  import QVBoxLayout      # Spread widgets vertically

from PyQt4.QtGui  import QPushButton
from PyQt4.QtGui  import QTreeWidget      # Lets add a tree to the dialog...why not? its easy!

class TestDialog( Dialog ):
   def __init__( self ):
      Dialog.__init__( self )

      # Create the main layout
      layout = QVBoxLayout()
      
      # Add a tree
      self.uiObjectTREE = QTreeWidget( self )  # Create a tree, as a child of this dialog
      layout.addWidget( self.uiObjectTREE )    # Add the tree to the layout

      # Add buttons
      self.uiOkBTN = QPushButton( self )
      self.uiOkBTN.setText( 'Ok' )
      
      self.uiCancelBTN = QPushButton( self )
      self.uiCancelBTN.setText( 'Cancel' )

      # Lay the buttons out horizontally
      hlayout = QHBoxLayout()
      hlayout.addWidget( self.uiOkBTN )
      hlayout.addWidget( self.uiCancelBTN )

      # Add the horizontal layout to the main one
      layout.addLayout( hlayout )

      # Set the dialogs layout to hold all these widgets
      self.setLayout( layout )

# Create the dialog
dialog = TestDialog()
dialog.show()
}}}

=== Qt Designer ===

One of the main strengths that you can get from Qt is the Designer.  Qt does a good job of creating a true separation between code and graphics.

You can drag and drop widgets onto your dialog, save out an xml (.ui) file that can be loaded in on the fly.  It also has Layouts.  Layouts allow you to easily create *resizable* dialogs (something that was always a problem in Maxscript rollouts)