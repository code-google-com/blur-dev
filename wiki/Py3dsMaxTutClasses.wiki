#summary Difference between Structs and Classes
#labels Python,3dsMax,Tutorial

= Structs & Classes =

In Maxscript you have the ability to create structs of data.  In Python, classes can do everything you can in a Maxscript struct - and oh so much more.

*Maxscript Struct*
{{{
/* create a struct */
struct MyStruct (
  _myArray   = #( "a", "b", "c" ),

  function addItem item = (
      append _myArray item
  ),
  function printItems = (
      print _myArray
  )
)

/* Create class instance */
instA = MyStruct()
instA.addItem( "d" )
instA.printItems()    /* result: #( "a", "b", "c", "d" ) */

/* Create class instance */
instB = MyStruct()
instB.addItem( "e" )
instB.printItems()    /* result: #( "a", "b", "c", "e" ) */
}}}

*Python Class*
{{{
# Create a class
class MyClass:
  _myArray  = [ 'a', 'b', 'c' ]

  def addItem( self, item ):
     self._myArray.append( item )
 
  def printItems( self ):
     print self._myArray

# Create class instance
instA = MyClass()
instA.addItem( 'd' )
instA.printItems()      # result: [ 'a', 'b', 'c', 'd' ]

# Create class instance
instB = MyClass()
instB.addItem( 'e' )
instB.printItems()      # result: [ 'a', b', 'c', 'd', 'e' ]
}}}

So, you can see that once again, there is some similarity, and yet, some big differences as well.

==== What is the 'self' variable?  Why don't I pass that into my function? ====

The 'self' variable is actually the instance of the class being passed into the function.  So when you call instA.printItems(), the method is actually getting instA as your first variable.  This way you can easily reference any individual instance of your class, as well as pass it along to other functions.  Something that was never available in Maxscript.

Whenever you're writing methods for a class, you always *must* declare self as the first variable being passed into your class.

==== Wait, but if the 'self' variable is the first variable passed in, why do I see 'd' in the second instances list? ====

This confused me for a long, long time when I started.  So this is the most important piece of information when dealing with classes:

 * Classes have a global scope, and a local scope:

   * Any member defined at the global level of a class becomes a *class member*, a shared member across all instances of that class

==== So how do I declare a member per-instance? ====

Every class in python starts with the __init__ method.  In fact, there are many built-in methods that can be overridden within your subclass.  All python built-in methods start and end with double-underscores - I'd suggest reading more about that online.

The quick-crash course solution to the above problem is like this:

*Python*
{{{
# Create a class
class MyClass:
  # Create the constructor method
  def __init__( self ):
     # So that '_myArray' is a propery of the class instance, and not of the class itself
     self._myArray  = [ 'a', 'b', 'c' ]

  def addItem( self, item ):
     self._myArray.append( item )
 
  def printItems( self ):
     print self._myArray

# Create class instance
instA = MyClass()
instA.addItem( 'd' )
instA.printItems()      # result: [ 'a', 'b', 'c', 'd' ]

# Create class instance
instB = MyClass()
instB.addItem( 'e' )
instB.printItems()      # result: [ 'a', b', 'c', 'e' ]
}}}

=== Object-Oriented Programming ===

Python is an Object-Oriented programming language, which means you can quickly and easily manage inheritance in your objects, something that Maxscript always lacked.

{{{
# Base class
class ClassA:
   def __init__( self, name ):
      self._name = name
      self._number = 10

   def displayName( self ):
      return '%s-%02i' % (self.name(), self.number())

   def name( self ):
      return self._name

   def number( self ):
      return self._number

# ClassB inherits from ClassA
class ClassB( ClassA ):
   def __init__( self ):
     # Call the base class constructor
     # Since we're calling ClassA's contructor directly, we have to pass in the self instance
     ClassA.__init__( self, 'MyName' )
     self._multiplier = 2

   def number( self ):
      # Overload the number method
      return ClassA.number( self ) * self.multiplier() # You can see the difference between calling a class method directly and from an instance

   def multiplier( self ):
      return self._multiplier

# Create an instance of ClassA

a = ClassA( 'A' )
print a.number(), a.displayName()

b = ClassB() # Does not need a name argument since its being set in its constructor
print b.number(), b.displayName()

# Ways to check subclass types
print type( b )                    # Checks the instance's class type
print issubclass( ClassB, ClassA ) # Checks to see if one class inherits from another
print isinstance( b, ClassA )      # Check to see if one instance inherits from another class
}}}

=== Next Topic ===

[Py3dsMaxTutValues Accessing 3dsMax Values]